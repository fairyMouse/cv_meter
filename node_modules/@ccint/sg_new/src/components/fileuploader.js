import $ from 'jquery'
import sg from '../sg.js'
import EXIF from 'exif-js'
import './fileuploader.css'

sg.Component.define('FileUploader', {
  properties: {
    _fileUrls: {},
    _fileNames: {},
    _files: [],
    maxSize: 0, // 文件大小上限，单位是b，如果是0，则没有限制
    extension: '*', // 文件类型，*表示所有文件，image|video|audio分别代表图片，视频，音频三个大类，小类型如：jpg,png,mp3等，多个类型用逗号隔开
    multiple: false, // 是否是多选
    preview: false, // 是否需要预览，提供blob或base64格式的字符串作为临时链接，如果是图片，可以直接用img标签展示，如果是音频，可以用audio播放
    autoSubmit: true, // 是否自动提交请求
    needFileCache: false, // 是否需要缓存文件，避免重复的本地文件被多次上传
    title: '', // 鼠标hover上去的title
    url: '', // 提交请求的url
    onError: null, // 错误回调
    onSelect: null, // 选中文件回调
    onSuccess: null, // 提交成功回调
    onComplete: null, // 请求完成回调
    onProgress: null, // 请求过程中的进度回调，如果文件过大可以用来做进度展示
    errorMap: { // 错误类型和提示
      ErrorMaxSize: '上传大小超出限制',
      ErrorType: '上传格式不合法',
      ErrorNotSupportPreview: '不支持文件预览，请使用其他浏览器'
    }
  },
  template: '<input class="sg_file_uploader" name="sg_uploader_file" type="file" tabindex="-1" {{if multiple}}multiple{{/if}} {{if title}}title="{{title}}"{{/if}} accept="{{extension}}">',
  onBeforeRender: function (next) {
    let self = this
    let arr_extension = sg.utils.getFileExt(self.extension)
    let str_extension
    if (arr_extension.length) {
      str_extension = arr_extension.join(',')
    } else {
      str_extension = '*/*'
    }
    next({
      extension: str_extension,
      multiple: self.multiple,
      title: self.title
    }, 1)
  },
  onRender: function () {
    let self = this
    let $dom = self.$dom

    // 判断是否支持File对象
    if (window.File) {
      $dom.bind('change', self.events.changeXhr)
    } else {
      // $dom.bind('change', self.events.changeForm);
    }
  },
  _getUploadUrl: function (url) {
    let self = this
    url = url || self.url
    if ($.isFunction(url)) {
      url = url.call(self)
    }
    return url
  },
  // 清除所选文件
  clear: function () {
    let self = this
    let $file = self.$dom
    $file.val('')
    self._files = []
  },
  submit: function (url) {
    let self = this
    if (window.File) {
      self.submitXhr(url)
    } else {
      self.submitForm(url)
    }
  },
  submitXhr: function (url) {
    let self = this
    url = self._getUploadUrl(url)
    for (let i = 0; i < self._files.length; i++) {
      self.submitXhrSingle(url, self._files[i])
    }
    self.clear()
  },
  submitXhrSingle: function (url, file) {
    let self = this
    let cache = self._fileNames[file.name]
    if (self.needFileCache && cache) {
      if (self.onComplete) {
        self.onComplete(file, cache)
      }
      if (self.onSuccess) {
        self.onSuccess(file, cache.data)
      }
      if (!self.multiple) {
        self.clear()
      }
      return
    }
    let xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4 && xhr.status >= 200) {
        let data = {}
        try {
          data = JSON.parse(xhr.responseText)
        } catch (e) {
        }

        if (self.onComplete) {
          self.onComplete(file, data)
        }

        if (data.data && self.onSuccess) {
          self._fileNames[file.name] = data
          self.onSuccess(file, data.data)
        } else if (!data.data && self.onError) {
          data.message = data.message || '上传失败!'
          self.onError(data, file)
        }
        if (!self.multiple) {
          self.clear()
        }
      }
    }
    if (xhr.upload && self.onProgress) {
      xhr.upload.onprogress = function (e) {
        if (e.lengthComputable) {
          self.onProgress(file, e.loaded, e.total)
        }
      }
    }

    url = sg.utils.addUrlParam(url, {
      sg_file_name: file.name
    })
    xhr.open('POST', url, true)
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest')
    xhr.setRequestHeader('Cache-Control', 'no-cache')
    xhr.setRequestHeader('Content-Type', 'application/octet-stream')
    xhr.send(file)
  },
  events: {
    changeXhr: function () {
      let self = this
      let $file = self.$dom
      let files = $file[0].files
      let tmp_file
      let files_copy = []
      let error
      let i
      let length
      let extension = sg.utils.getFileExt(self.extension)
      let error_file
      if (!files.length) {
        return
      }
      for (i = 0, length = files.length; i < length; i++) {
        tmp_file = files[i]
        if ((self.extension === 'image' && !/image\//ig.test(tmp_file.type)) || (self.extension === 'audio' && !/audio\//ig.test(tmp_file.type)) || (self.extension === 'video' && !/video\//ig.test(tmp_file.type))) {
          error = 'ErrorType'
          error_file = tmp_file
          break
        } else if ((self.extension !== 'image' && self.extension !== 'audio' && self.extension !== 'video') && (extension.length && $.inArray(tmp_file.type, extension) === -1)) {
          error = 'ErrorType'
          error_file = tmp_file
          break
        }
        if (self.maxSize && tmp_file.size > self.maxSize) {
          error = 'ErrorMaxSize'
          error_file = tmp_file
          break
        } else if ((self.extension !== 'image' && self.extension !== 'audio' && self.extension !== 'video') && (extension.length && $.inArray(tmp_file.type, extension) === -1)) {
          error = 'ErrorType'
          break
        }
        if (self.maxSize && tmp_file.size > self.maxSize) {
          error = 'ErrorMaxSize'
          break
        }
        files_copy.push(tmp_file)
      }
      // 清空文件选择
      $file.val('')
      if (error) {
        if (self.onError) {
          self.onError({
            errno: error,
            message: self.errorMap[error]
          }, error_file)
        }
        return
      }
      self._files = files = self._files.concat(files_copy)
      function next () {
        if (self.onSelect) {
          self.onSelect(files)
        }
        if (self.autoSubmit) {
          self.submitXhr()
        }
      }

      // 针对ios拍照的图片处理旋转问题
      let tmpIndex = 0

      rotateByExif(files[tmpIndex])

      function rotateByExif (image_file) {
        if (!image_file) {
          final()
        } else if (!/image/i.test(image_file.type)) {
          tmpIndex++
          rotateByExif(files[tmpIndex])
        } else {
          EXIF.getData(image_file, function () {
            let orient = EXIF.getTag(this, 'Orientation')
            function callback (rotate_image) {
              if (rotate_image) {
                files[tmpIndex] = rotate_image
              }
              tmpIndex++
              rotateByExif(files[tmpIndex])
            }
            switch (orient) {
              case 3:
                sg.utils.rotateImage(image_file, 'bottom', callback)
                break
              case 6:
                sg.utils.rotateImage(image_file, 'right', callback)
                break
              case 8:
                sg.utils.rotateImage(image_file, 'left', callback)
                break
              default:
                callback()
                break
            }
          })
        }
      }

      function final () {
        if (self.preview) {
          // 清除上一次的blob url
          if (window.URL) {
            for (i in self._fileUrls) {
              if (self._fileUrls.hasOwnProperty(i)) {
                URL.revokeObjectURL(self._fileUrls[i])
              }
            }
            self._fileUrls = []
            // 创建blob url用于预览
            for (i = 0, length = files.length; i < length; i++) {
              files[i].url = URL.createObjectURL(files[i])
              let tmp_obj = {}
              tmp_obj[files[i].name] = files[i].url
              self._fileUrls.push(tmp_obj)
            }
            next()
          } else if (window.FileReader) {
            let loaded = 0
            length = files.length
            for (i = 0; i < length; i++) {
              (function (file) {
                let reader = new FileReader()
                reader.onload = function () {
                  file.url = reader.result
                  loaded++
                  if (loaded === length) {
                    next()
                  }
                }
                reader.readAsDataURL(file)
              })(files[i])
            }
          } else if (self.onError) {
            error = 'ErrorNotSupportPreview'
            self.onError({
              errno: error,
              message: self.errorMap[error]
            })
          }
        } else {
          next()
        }
      }
    }
  }
})
