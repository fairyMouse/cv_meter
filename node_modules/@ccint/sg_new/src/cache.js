let HasProp = {}.hasOwnProperty
/**
 * 检测某个对象是否拥有某个属性
 * @param  {Object}  owner 检测对象
 * @param  {String}  prop  属性
 * @return {Boolean} 是否拥有prop属性
 */
let Has = function (owner, prop) {
  return owner ? HasProp.call(owner, prop) : owner // false 0 null '' undefined
}

let CacheLatest = 0

/**
 * cache 排序
 * @return {number}
 */
function CacheSort (a, b) {
  return (b.f === a.f) ? b.t - a.t : b.f - a.f
}

let Cache = function (max, buffer) {
  let me = this
  if (!me.get) return new Cache(max, buffer)
  me.c = []
  me.x = max || 20
  me.b = me.x + (isNaN(buffer) ? 5 : buffer)
}

/**
 * 混合对象的属性
 * @param  {Object} aim    要mix的目标对象
 * @param  {Object} src    mix的来源对象
 * @param  {Object} ignore 在复制时，忽略的值
 * @return {Object}
 */
let Mix = function (aim, src, ignore) {
  for (let p in src) {
    if (!ignore || !Has(ignore, p)) {
      aim[p] = src[p]
    }
  }
  return aim
}

Mix(Cache.prototype, {
  get: function (key) {
    let me = this
    let c = me.c
    let r
    if (Has(c, key)) {
      r = c[key]
      if (r.f >= 1) {
        r.f++
        r.t = CacheLatest++
        //
        r = r.v
        //
      }
    }
    return r
  },
  set: function (okey, value) {
    let me = this
    let c = me.c

    let key = okey
    let r = c[key]

    if (!Has(c, key)) {
      if (c.length >= me.b) {
        c.sort(CacheSort)
        let t = me.b - me.x
        while (t--) {
          r = c.pop()
          //
          delete c[r.k]
        }
      }
      r = {}
      c.push(r)
      c[key] = r
    }
    r.o = okey
    r.k = key
    r.v = value
    r.f = 1
    r.t = CacheLatest++
    return value
  },
  del: function (k) {
    let c = this.c
    let r = c[k]
    if (r) {
      r.f = -1E5
      r.v = ''
      delete c[k]
    }
  },
  has: function (k) {
    return Has(this.c, k)
  },
  reset: function () {
    let me = this
    me.c = []
  }
}, false)

export default Cache
